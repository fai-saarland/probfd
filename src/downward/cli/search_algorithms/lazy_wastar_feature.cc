#include "downward/cli/plugins/plugin.h"

#include "downward/cli/search_algorithm_options.h"

#include "downward/search_algorithms/lazy_search.h"
#include "downward/search_algorithms/search_common.h"

#include "downward/evaluator.h"
#include "downward/task_dependent_factory.h"

using namespace std;
using namespace downward;
using namespace downward::lazy_search;

using namespace downward::cli::plugins;

using downward::cli::add_search_algorithm_options_to_feature;
using downward::cli::add_successors_order_options_to_feature;

using downward::cli::get_search_algorithm_arguments_from_options;
using downward::cli::get_successors_order_arguments_from_options;

namespace {

constexpr auto DEFAULT_LAZY_BOOST = "1000";

class LazyWAstarSearchFactory : public TaskDependentFactory<SearchAlgorithm> {
    OperatorCost cost_type;
    int bound;
    double max_time;
    const std::string& description;
    utils::Verbosity verbosity;
    bool reopen_closed;
    bool randomize_successors;
    bool preferred_successors_first;
    int random_seed;
    vector<shared_ptr<TaskDependentFactory<Evaluator>>> eval_factories;
    vector<shared_ptr<TaskDependentFactory<Evaluator>>> preferred_factories;
    int boost;
    int w;

public:
    explicit LazyWAstarSearchFactory(
        OperatorCost cost_type,
        int bound,
        double max_time,
        const std::string& description,
        utils::Verbosity verbosity,
        bool reopen_closed,
        bool randomize_successors,
        bool preferred_successors_first,
        int random_seed,
        vector<shared_ptr<TaskDependentFactory<Evaluator>>> eval_factories,
        vector<shared_ptr<TaskDependentFactory<Evaluator>>> preferred_factories,
        int boost,
        int w)
        : cost_type(cost_type)
        , bound(bound)
        , max_time(max_time)
        , description(description)
        , verbosity(verbosity)
        , reopen_closed(reopen_closed)
        , randomize_successors(randomize_successors)
        , preferred_successors_first(preferred_successors_first)
        , random_seed(random_seed)
        , eval_factories(std::move(eval_factories))
        , preferred_factories(std::move(preferred_factories))
        , boost(boost)
        , w(w)
    {
    }

    unique_ptr<SearchAlgorithm>
    create_object(const SharedAbstractTask& task) override
    {
        std::vector<std::shared_ptr<Evaluator>> evals;

        for (auto& eval_factory : eval_factories) {
            evals.emplace_back(eval_factory->create_object(task));
        }

        std::vector<std::shared_ptr<Evaluator>> preferred;

        for (auto& preferred_factory : preferred_factories) {
            preferred.emplace_back(preferred_factory->create_object(task));
        }

        auto open_list = search_common::create_wastar_edge_open_list(
            evals,
            !preferred.empty(),
            boost,
            w,
            verbosity);

        return std::make_unique<LazySearch>(
            std::move(open_list),
            reopen_closed,
            std::move(preferred),
            randomize_successors,
            preferred_successors_first,
            random_seed,
            task,
            cost_type,
            bound,
            max_time,
            description,
            verbosity);
    }
};

class LazyWAstarSearchFeature
    : public TypedFeature<
          TaskDependentFactory<SearchAlgorithm>,
          LazyWAstarSearchFactory> {
public:
    LazyWAstarSearchFeature()
        : TypedFeature("lazy_wastar")
    {
        document_title("(Weighted) A* search (lazy)");
        document_synopsis(
            "Weighted A* is a special case of lazy best first search.");

        add_list_option<shared_ptr<TaskDependentFactory<Evaluator>>>(
            "evals",
            "evaluators");
        add_list_option<shared_ptr<TaskDependentFactory<Evaluator>>>(
            "preferred",
            "use preferred operators of these evaluators",
            "[]");
        add_option<bool>("reopen_closed", "reopen closed nodes", "true");
        add_option<int>(
            "boost",
            "boost value for preferred operator open lists",
            DEFAULT_LAZY_BOOST);
        add_option<int>("w", "evaluator weight", "1");
        add_successors_order_options_to_feature(*this);
        add_search_algorithm_options_to_feature(*this, "lazy_wastar");

        document_note(
            "Open lists",
            "In the general case, it uses an alternation open list "
            "with one queue for each evaluator h that ranks the nodes "
            "by g + w * h. If preferred operator evaluators are used, "
            "it adds for each of the evaluators another such queue that "
            "only inserts nodes that are generated by preferred operators. "
            "In the special case with only one evaluator and no preferred "
            "operator evaluators, it uses a single queue that "
            "is ranked by g + w * h. ");
        document_note(
            "Equivalent statements using general lazy search",
            "\n```\n--evaluator h1=eval1\n"
            "--search lazy_wastar([h1, eval2], w=2, preferred=h1,\n"
            "                     bound=100, boost=500)\n```\n"
            "is equivalent to\n"
            "```\n--evaluator h1=eval1 --heuristic h2=eval2\n"
            "--search lazy(alt([single(sum([g(), weight(h1, 2)])),\n"
            "                   single(sum([g(), weight(h1, 2)]), "
            "pref_only=true),\n"
            "                   single(sum([g(), weight(h2, 2)])),\n"
            "                   single(sum([g(), weight(h2, 2)]), "
            "pref_only=true)],\n"
            "                  boost=500),\n"
            "              preferred=h1, reopen_closed=true, bound=100)\n```\n"
            "------------------------------------------------------------\n"
            "```\n--search lazy_wastar([eval1, eval2], w=2, bound=100)\n```\n"
            "is equivalent to\n"
            "```\n--search lazy(alt([single(sum([g(), weight(eval1, 2)])),\n"
            "                   single(sum([g(), weight(eval2, 2)]))],\n"
            "                  boost=1000),\n"
            "              reopen_closed=true, bound=100)\n```\n"
            "------------------------------------------------------------\n"
            "```\n--search lazy_wastar([eval1, eval2], bound=100, "
            "boost=0)\n```\n"
            "is equivalent to\n"
            "```\n--search lazy(alt([single(sum([g(), eval1])),\n"
            "                   single(sum([g(), eval2]))])\n"
            "              reopen_closed=true, bound=100)\n```\n"
            "------------------------------------------------------------\n"
            "```\n--search lazy_wastar(eval1, w=2)\n```\n"
            "is equivalent to\n"
            "```\n--search lazy(single(sum([g(), weight(eval1, 2)])), "
            "reopen_closed=true)\n```\n",
            true);
    }

    shared_ptr<LazyWAstarSearchFactory>
    create_component(const Options& opts, const utils::Context& context)
        const override
    {
        verify_list_non_empty<shared_ptr<Evaluator>>(context, opts, "evals");

        return make_shared_from_arg_tuples<LazyWAstarSearchFactory>(
            get_search_algorithm_arguments_from_options(opts),
            opts.get<bool>("reopen_closed"),
            get_successors_order_arguments_from_options(opts),
            opts.get_list<shared_ptr<TaskDependentFactory<Evaluator>>>("evals"),
            opts.get_list<shared_ptr<TaskDependentFactory<Evaluator>>>(
                "preferred"),
            opts.get<int>("boost"),
            opts.get<int>("w"));
    }
};

FeaturePlugin<LazyWAstarSearchFeature> _plugin;

} // namespace
